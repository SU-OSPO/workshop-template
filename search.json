[
  {
    "objectID": "01_r_unit/index.html",
    "href": "01_r_unit/index.html",
    "title": "Example R Unit",
    "section": "",
    "text": "While you can make plots with just the packages that come bundled with base R, many R users make their visualizations entirely using the ggplot2 package and an ecosystem of packages designed around it.\n\n# load the ggplot2 package\nlibrary(ggplot2)\n\nAs with the previous session, we’ll be using the Palmer penguins dataset. While we built our own combined dataset in the introduction session, now we’re going to use the built-in raw dataset included in the palmerpenguins package (install this first if you don’t have it yet). First, let’s load the package. By loading the package, it gives us access to the penguins_raw data object that is included (notice that it isn’t shown in our Global Environment, but you can see it in the environment of the palmerpenguins package). Let’s inspect the data using the glimpse() function (we’ll learn more about the dplyr package in the next session).\n\nlibrary(palmerpenguins)\n\n\nAttaching package: 'palmerpenguins'\n\n\nThe following objects are masked from 'package:datasets':\n\n    penguins, penguins_raw\n\ndplyr::glimpse(penguins_raw)\n\nRows: 344\nColumns: 17\n$ studyName             &lt;chr&gt; \"PAL0708\", \"PAL0708\", \"PAL0708\", \"PAL0708\", \"PAL…\n$ `Sample Number`       &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1…\n$ Species               &lt;chr&gt; \"Adelie Penguin (Pygoscelis adeliae)\", \"Adelie P…\n$ Region                &lt;chr&gt; \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\"…\n$ Island                &lt;chr&gt; \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgerse…\n$ Stage                 &lt;chr&gt; \"Adult, 1 Egg Stage\", \"Adult, 1 Egg Stage\", \"Adu…\n$ `Individual ID`       &lt;chr&gt; \"N1A1\", \"N1A2\", \"N2A1\", \"N2A2\", \"N3A1\", \"N3A2\", …\n$ `Clutch Completion`   &lt;chr&gt; \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"No\", …\n$ `Date Egg`            &lt;date&gt; 2007-11-11, 2007-11-11, 2007-11-16, 2007-11-16,…\n$ `Culmen Length (mm)`  &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34…\n$ `Culmen Depth (mm)`   &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18…\n$ `Flipper Length (mm)` &lt;dbl&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190,…\n$ `Body Mass (g)`       &lt;dbl&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 34…\n$ Sex                   &lt;chr&gt; \"MALE\", \"FEMALE\", \"FEMALE\", NA, \"FEMALE\", \"MALE\"…\n$ `Delta 15 N (o/oo)`   &lt;dbl&gt; NA, 8.94956, 8.36821, NA, 8.76651, 8.66496, 9.18…\n$ `Delta 13 C (o/oo)`   &lt;dbl&gt; NA, -24.69454, -25.33302, NA, -25.32426, -25.298…\n$ Comments              &lt;chr&gt; \"Not enough blood for isotopes.\", NA, NA, \"Adult…\n\n\nAs we discovered before, this dataset includes many different measurements for individual penguins from three different studies. The studies cover both sexes of three different species of penguins from three different islands in the Palmer Archipelago.",
    "crumbs": [
      "Example R Unit"
    ]
  },
  {
    "objectID": "01_r_unit/index.html#other-layers",
    "href": "01_r_unit/index.html#other-layers",
    "title": "Example R Unit",
    "section": "Other layers",
    "text": "Other layers\nThere are many other types of plots that we can make with ggplot2.\n\nHistograms\nWe can visualize the density of values for a single variable with a histogram:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, fill = Species) +\n  geom_histogram() +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nHistograms don’t require a y-axis aesthetic by default. The counts are tabulated for you. If you specify a “fill” aesthetic, the default is to stack the bars which can sometimes be a bit misleading. You can also dodge them to fix this:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, fill = Species) +\n  geom_histogram(position = \"dodge\") +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\nBoxplots and Violin Plotss\nWe can visualize the density of values for a single variable across a discrete variable with boxplots or violin plots:\n\nggplot(penguins_raw) +\n  aes(x = Island, y = `Culmen Length (mm)`) +\n  geom_boxplot() +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n\nggplot(penguins_raw) +\n  aes(x = Island, y = `Culmen Length (mm)`) +\n  geom_violin(scale = \"width\", draw_quantiles = c(0.25, 0.5, 0.75)) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_ydensity()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeom options\n\n\n\nNote that many of these “geom”s have lots of options. For example, here we’ve decided to scale all of the violin plots to the same width and to draw the quartiles on them (mimicking the boxplots above). You can see all of the options for a geom by checking out it’s help page (?geom_violin) or on the ggplot website.\n\n\n\n\n2D Contours\nWe can also visualize the density of values across two continuous variables using a 2D contour. Here we’ll use the isotope data from the penguins dataset. We’ll expand the axes a little bit to better show the contours:\n\nggplot(penguins_raw) +\n  aes(x = `Delta 15 N (o/oo)`, y = `Delta 13 C (o/oo)`) +\n  geom_density_2d(linewidth = 0.25, colour = \"black\") +\n  scale_x_continuous(limits = c(7, 10.5)) +\n  scale_y_continuous(limits = c(-27.5, -23.5)) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\nWarning: Removed 14 rows containing non-finite outside the scale range\n(`stat_density2d()`).\n\n\n\n\n\n\n\n\n\n\n\nTime Series\nSince there isn’t really any time series data in the penguins dataset, we’ll take a quick detour and use the built-in economics dataset to explore visualizing a time series. In this case, we are looking at unemployment over time:\n\nggplot(economics, aes(x = date, y = unemploy)) +\n  geom_line() +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\ngeom_path() lets you explore how two variables are related over time. For example, unemployment and personal savings rate:\n\nggplot(economics, aes(x = unemploy / pop, y = psavert)) +\n  geom_path(aes(colour = as.numeric(date))) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMultiple columns for individual aesthetics\n\n\n\nNote how we’ve used multiple columns of the data to define the x-axis here. You can use any sort of mathetical operators to combine multiple columns into a single aesthetic, as long as you are doing row-wise math. We’ll learn about summary statistics for groups of rows in the next session.",
    "crumbs": [
      "Example R Unit"
    ]
  },
  {
    "objectID": "01_r_unit/index.html#combining-layers",
    "href": "01_r_unit/index.html#combining-layers",
    "title": "Example R Unit",
    "section": "Combining layers",
    "text": "Combining layers\nWe can also combine multiple layers to show the same data in different ways in the same plot. For example, we could show the raw data for the above contour plot in addition to the contours:\n\nggplot(penguins_raw) +\n  aes(x = `Delta 15 N (o/oo)`, y = `Delta 13 C (o/oo)`) +\n  geom_point() +\n  geom_density_2d_filled(alpha = 0.5) +\n  geom_density_2d(linewidth = 0.25, colour = \"black\") +\n  scale_x_continuous(limits = c(7, 10.5)) +\n  scale_y_continuous(limits = c(-27.5, -23.5)) +\n  coord_cartesian(expand = FALSE) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\nWarning: Removed 14 rows containing non-finite outside the scale range\n(`stat_density2d_filled()`).\n\n\nWarning: Removed 14 rows containing non-finite outside the scale range\n(`stat_density2d()`).\n\n\nWarning: Removed 14 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLayer order\n\n\n\nWhen combining layers, the layers are added to the plot in order, so in this case the points are the bottom layer and the contour lines are the top layer. We changed the alpha of the middle layer to prevent the points from being blocked. I’ve also used the coord_cartesian() function to remove the default axis expansion. This way the background color reaches both axes and doesn’t have a white gap.",
    "crumbs": [
      "Example R Unit"
    ]
  },
  {
    "objectID": "01_r_unit/index.html#facetting",
    "href": "01_r_unit/index.html#facetting",
    "title": "Example R Unit",
    "section": "Facetting",
    "text": "Facetting\nLet’s take our scatterplot example from earlier:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, y = `Flipper Length (mm)`,\n      color = Island, shape = Sex) +\n  geom_point() +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_x_continuous(name = \"Body Mass (grams)\") +\n  scale_y_continuous(name = \"Flipper Length (millimeters)\") +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nNow, what if we wanted to also split the data by the species of the penguins? We’re already using color and shape, so what other aesthetic could we use? We could possible use some shapes that have both a fill and outline color, but that sounds messy. Instead of using another aesthetic, we could also use a facet. This splits the chart into multiple panels:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, y = `Flipper Length (mm)`,\n      color = Island, shape = Sex) +\n  geom_point() +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_x_continuous(name = \"Body Mass (grams)\") +\n  scale_y_continuous(name = \"Flipper Length (millimeters)\") +\n  facet_wrap(vars(Species), ncol = 1) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe can get even crazier by faceting by multiple variables:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, y = `Flipper Length (mm)`,\n      color = Island, shape = Sex) +\n  geom_point() +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_x_continuous(name = \"Body Mass (grams)\") +\n  scale_y_continuous(name = \"Flipper Length (millimeters)\") +\n  facet_grid(rows = vars(Species), cols = vars(studyName)) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nOK, maybe we’ve gone a little too far here, but you get the picture!",
    "crumbs": [
      "Example R Unit"
    ]
  },
  {
    "objectID": "02_python_unit/index.html",
    "href": "02_python_unit/index.html",
    "title": "Example Python Unit",
    "section": "",
    "text": "This Python tutorial will cover the basics of",
    "crumbs": [
      "Example Python Unit"
    ]
  },
  {
    "objectID": "02_python_unit/index.html#types-in-computing",
    "href": "02_python_unit/index.html#types-in-computing",
    "title": "Example Python Unit",
    "section": "Types in computing",
    "text": "Types in computing\nIn computing, we deal with values, different numbers, text, images (which are numbers), boolean (logical). These values need to be represented in the memory of a computer, that is a number of binary switches (“0’s and 1’s”).\n\nIntegers\nA simple example is an integer number that can be expressed in the base2 (in the example, using 4 “bits”): 0001 is 1 in decimal, 0101 is (from left to right \\(0\\cdot2^3 + 1\\cdot2^2 + 0\\cdot2^1 + 1 \\cdot 2^0(=1) = 5\\). Using enough bits, we can represent any integer number (and use, for example, the leftmost bit as a flag to indicate that a minus is in front of it in order to produce a negative number). Technically, the types encountered are usually called int32, int64 (being the most common ones, but others exist too), where the trailing number indicates the number of bits used. In Python, we do not need to take care of it and integers are “precise enough”. A huge advantage of using Python!\nComparing integer numbers is always correct, because each integer has one, and exactly one representation.\n\n\nStrings (aka text)\nHaving defined integers, it’s easy to define text: each letter corresponds to an integer number (hidden to us users). All that is needed is something that marks a stream of bites as “text” and then evaluates that a certain number corresponds to a letter.\n\n\nFloating point numbers\nThis is where things get a bit tricky: while there is exactly one integer between the integers 4 and 6, for example, there are infinitly many floating point numbers between, say 3.1 and 3.2 and the number of digits can easily be large. This leads to a practical problem: we cannot accurately represent floating point numbers! 3.1 maybe is not equal to 3.1!\nFloating point numbers consist of two parts: an “integer-like” part, that is, a numeric value. And another part that defines the exponent of a base that the numerical value is multiplied by.\nImagine that every float is like an integer, “shifted” to the left or right.\nThe types are usually called float32 or float64 (and more). Usually, use float64 if ever needed for any scientific computing (machine learning being a notable exception).\nA number like 10/3 needs infinitely many digits to represent it exactly, but due to the limited precision that can be stored, it will be truncated in the computer. Therefore \\((10 / 3) \\cdot 3\\) equals \\(10\\), but a computer will return a number like 9.99999999 (with many, typically 8 or 16 digits for a float 32 or float64 respectively), but limited.\n(Python sometimes tries to hide this fact with some numbers, but nothing to rely on)\nAnother consequence is limited precision: adding a very small number to a very large one (i.e. if the small one is smaller than the precision that the large one is stored with, the small one will be “ignored”, as it first has to be converted to the same representation as the large one.",
    "crumbs": [
      "Example Python Unit"
    ]
  },
  {
    "objectID": "02_python_unit/index.html#basic-types-and-operations",
    "href": "02_python_unit/index.html#basic-types-and-operations",
    "title": "Example Python Unit",
    "section": "Basic types and operations",
    "text": "Basic types and operations\nPython has several basic types - numerical (float, int, complex) - string - bool\nThere are several operations defined on them, as we have already seen in examples.\n\na = 1  # creates an integer\n\nb = 3.4  # float\n\n# several ways for strings\nc = \"hello\"\nd = 'world'\ncd = \"welcome to this 'world' here\"  # we can now use '' inside (or vice versa)\ne = \"\"\"hello world\"\"\"  # which we can also wrap\ne2 = \"\"\"hello\nworld\ncome here!\"\"\"\n\ng = True\n\nprint(a, b, c, d, cd, e)\nprint(e2)\nprint(g)\n\n1 3.4 hello world welcome to this 'world' here hello world\nhello\nworld\ncome here!\nTrue\n\n\n\n  type(a) \n\nint\n\n\nWith type(...), we can determine the type of an object.",
    "crumbs": [
      "Example Python Unit"
    ]
  },
  {
    "objectID": "02_python_unit/index.html#strong-typing",
    "href": "02_python_unit/index.html#strong-typing",
    "title": "Example Python Unit",
    "section": "strong typing",
    "text": "strong typing\nPython is strongly typed. This means that the type of the variable matters and some interactions between certain types are not directly possible.\n\na = 1\nb = 2\n\n\na + b\n\n3\n\n\nThese are two integers. We are not surprised that this works. What about the following?\n\nmix_str_int = a + \"foo\"\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 mix_str_int = a + \"foo\"\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nMaybe the following works?\n\nmix_str_int2 = a + \"5\"\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 mix_str_int2 = a + \"5\"\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nPython is strict on the types, but we can sometimes convert from one type to another, explicitly:\n\na + int(\"5\")\n\n6\n\n\n…which works because int(\"5\") -&gt; 5.\nThere are though some implicit conversions in Python, let’s look at the following:\n\nf = 1.2\nprint(type(f))\n\n&lt;class 'float'&gt;\n\n\n\nint_plus_float = a + f\nprint(type(int_plus_float))\n\n&lt;class 'float'&gt;\n\n\nThis is one of the few examples, where Python automatically converts the integer type to a float. The above addition actually reads as\n\nint_plus_float = float(a) + f\n\nSimilar with booleans as they are in principle 1 (True) and 0 (False)\n\nTrue + 5\n\n6\n\n\nFor readability, it is usually better to write an explicit conversion.",
    "crumbs": [
      "Example Python Unit"
    ]
  },
  {
    "objectID": "02_python_unit/index.html#container-types",
    "href": "02_python_unit/index.html#container-types",
    "title": "Example Python Unit",
    "section": "Container types",
    "text": "Container types\nPython has several container types as also found in other languages. The most important ones are: - list (~array in other languages) - dict (~hash table in other languages)\nThey can contain other objects which can then be assigned and accessed via the [] operator (we will have a closer look at operators later on)\nA list stores elements by indices, which are integers, while a dict stores elements by a key, which can be “any basic type” (to be precise: by their “hash”, it can be any immutable type).\n\n# creating a list\nlist1 = [1, 2, 3]\nprint(list1)\n\n[1, 2, 3]\n\n\nWe can access these element by indices, starting from 0\n\nlist1[0]\n\n1\n\n\nWe can also assign a value to an place in the list\n\nlist1[1] = 42\nprint(list1)\n\n[1, 42, 3]\n\n\nand it can be extended with elements\n\nlist1.append(-5)\nprint(list1)\n\n[1, 42, 3, -5]\n\n\nChoosing a value that is not contained in the list raises an error. It is verbose, read and understand it.\nBeing able to understand and interpret errors correctly is a key to becoming better in coding.\n\nlist1[14]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 list1[14]\n\nIndexError: list index out of range\n\n\n\nWe can play a similar game with dicts\n\nperson = {'name': \"Rafael Silva Coutinho\", 'age': 37, 5: True, 11: \"hi\"}  # we can use strings but also other elements\nprint(person)\n\n{'name': 'Rafael Silva Coutinho', 'age': 37, 5: True, 11: 'hi'}\n\n\n\nprint(person['name'])\nprint(person[5])\nprint(person[11])\n\nRafael Silva Coutinho\nTrue\nhi\n\n\nWe can also assign a new value to a key.\n\nperson['age'] = '42.00001'\nprint(person)\n\n{'name': 'Rafael Silva Coutinho', 'age': '42.00001', 5: True, 11: 'hi'}\n\n\n… or even extend it by assigning to a key that did not yet exists in the dict\n\nperson['alias'] = \"rsilvaco\"\nprint(person)\n\n{'name': 'Rafael Silva Coutinho', 'age': '42.00001', 5: True, 11: 'hi', 'alias': 'rsilvaco'}\n\n\nAs we see this works. Notice, that the dict has changed, same as the list before.\nAgain, selecting a key that is not contained in the dict raises an error.\n\nperson['nationality']\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 person['nationality']\n\nKeyError: 'nationality'\n\n\n\nAs any object in Python, there are many useful methods on list and dict that help you accomplish things. For example, what if we want to retrieve a value from a dict only if the key is there and otherwise return a default value? We can use get:\n\nhair_color = person.get('hair_color', 'unknown color')  # the second argument gets returned if key is not in dict\nprint(hair_color)\n\nunknown color",
    "crumbs": [
      "Example Python Unit"
    ]
  },
  {
    "objectID": "02_python_unit/index.html#mutability",
    "href": "02_python_unit/index.html#mutability",
    "title": "Example Python Unit",
    "section": "Mutability",
    "text": "Mutability\nPython has a fundamental distinction between mutable and immutable types.\nMutable means, an object can be changed Immutable means, an object can not be changed\nAs an example, 5 can not change; in general the basic types we looked at cannot change. We can change the value that is assigned to a variable, but the object 5 remains the same. The list and dicts we have seen above on the other hand are mutable, they have changed over the course of execution.\nEvery mutable object has an immutable counterpart (but not vice-versa): - list -&gt; tuple - dict -&gt; frozendict - set -&gt; frozenset - etc.\n\n# creating a tuple\ntuple1 = (1, 3, 5)\n# or from a list\ntuple_from_list = tuple(list1)\n\n\nlist2 = [4, 5]\ntuple2 = (3, 4)\nlist3 = list(tuple2)\n\n\nprint(list2)\nprint(tuple2)\nprint(list3)\n\n[4, 5]\n(3, 4)\n[3, 4]\n\n\nWhile we can access the elements as we can for a list, we can neither assign nor append (or in generate mutate the object:\n\nprint(tuple1[1])  # access works!\n\n3\n\n\n\ntuple1[0] = 5\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[27], line 1\n----&gt; 1 tuple1[0] = 5\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nWe will soon see the effects and needs for this…\nExercise\nCreate a list with 3 elements. Then create a tuple with 5 elements, one of them being the list. Change an element in the list. Did it change in the tuple? Do you understand this?\n\nmy_list = [1, 2, 3]\nmy_tuple = (4, 5, my_list, 7, 8)\n\n\nmy_list[0] = 8   \nprint(my_tuple)\n\n(4, 5, [8, 2, 3], 7, 8)",
    "crumbs": [
      "Example Python Unit"
    ]
  },
  {
    "objectID": "02_python_unit/index.html#dynamic-typing",
    "href": "02_python_unit/index.html#dynamic-typing",
    "title": "Example Python Unit",
    "section": "Dynamic typing",
    "text": "Dynamic typing\nPython is dynamically typed. This means that a variable, which once was an int, such as a, can be assigned a value of another type (this maybe sounds trivial, but this is not possible to do in many other languages).\n\na = 1\nprint(a)\n\n1\n\n\n\na = \"one\"\nprint(a)\n\none\n\n\n\na = list1\nprint(a)\n\n[1, 42, 3, -5]\n\n\n… and so on",
    "crumbs": [
      "Example Python Unit"
    ]
  },
  {
    "objectID": "02_python_unit/index.html#python-variable-assignement",
    "href": "02_python_unit/index.html#python-variable-assignement",
    "title": "Example Python Unit",
    "section": "Python variable assignement",
    "text": "Python variable assignement\nAssigning something to a variable in Python makes a name point to an actual object, so the name is only a reference. For example creating the variable a and assigning it the object 5 looks like this: \n\na = 3\nlist_a = [1, 2]\nprint(a)\nprint(list_a)\n\n3\n[1, 2]\n\n\n\n\n\nreference2\n\n\n\nb = a  # this assigns the reference of a to b\nlist_b = list_a\nprint(a, b)\nprint(list_a, list_b)\n\n3 3\n[1, 2] [1, 2]\n\n\nBoth objects, b and list_b point now to the same objects in memory as a and list_a respectively. Re-assigning a variable let’s it point to a different object \n\na = 'spam'\nlist_a = [1, 5, 2, 'world', 1]\nprint(a, b)\nprint(list_a, list_b)\n\nspam 3\n[1, 5, 2, 'world', 1] [1, 2]\n\n\nLet’s make them point to the same object again:\n\nb = a\nlist_b = list_a \nprint(a, b)\nprint(list_a, list_b)\n\nspam spam\n[1, 5, 2, 'world', 1] [1, 5, 2, 'world', 1]\n\n\n\nlist_a[1] = 'hello'\nprint(list_a, list_b)\n\n[1, 'hello', 2, 'world', 1] [1, 'hello', 2, 'world', 1]\n\n\nNow we understand what happend: the object that both variables are pointing to simply changed. This is impossible with immutable objects (such as 3), since they are immutable.\nMutable objects usually offer the ability to create a copy.\n\nlist_c = list_a.copy()  # now there are two identical lists in the memory\n\n\nlist_a[2] = 'my'\nprint(list_a)\nprint(list_b)\nprint(list_c)\n\n[1, 'hello', 'my', 'world', 1]\n[1, 'hello', 'my', 'world', 1]\n[1, 'hello', 2, 'world', 1]\n\n\nlist_a and list_b, pointing to the same object that was mutated, have changed, while list_c, pointing to a different object, remained the same.\nLet’s have a look at two operators: the “trivial” == and the is: we know == pretty well, it tells whether the left and the right side are the same. More specific, it tells whether both sides have/represent the same value, not whether they are in fact the same object! The operator is tells us, whether two objects are the same object (compare our assignement model above!).\n\nprint(list_a == list_c)  # not the same\nprint(list_a == list_b)  # the same\n\nFalse\nTrue\n\n\n\nlist_c[2] = 'my'  # make it the same as the other lists\nprint(list_a == list_c)\n\nTrue\n\n\nBut, as we learned before, they are not the same objects!\n\nprint(list_a is list_c)  # nope!\nprint(list_a is list_b)  # yes!\n\nFalse\nTrue\n\n\nUsually, we are interested to compare the values, using == (notable exception: checking, if a value is None means to check using the identity equality is.\nExercise 2: Create a list a = [1, 2, 3] and create a new variable b and assign it to a. Compare a and b using == and is. Print the results. Modify a by appending 4 to it and print b. Do you understand why you have this solution?\n\n# Step 1: Create a list\na = [1, 2, 3]\n\n# Step 2: Assign a to b\nb = a\n\n# Step 3: Compare a and b using == and is\nprint(\"a == b:\", a == b)  # Expected output: True\nprint(\"a is b:\", a is b)  # Expected output: True\n\n# Step 4: Modify a by appending 4\na.append(4)\n\n# Step 5: Print b\nprint(\"b:\", b)  # Expected output: [1, 2, 3, 4]\n\na == b: True\na is b: True\nb: [1, 2, 3, 4]\n\n\nExplanation:\na == b and a is b are both True because b is assigned directly from a, meaning they refer to the same list object. After appending 4 to a, b also changes because both a and b point to the same list in memory.",
    "crumbs": [
      "Example Python Unit"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "[INSERT WORKSHOP SHORT TITLE]",
    "section": "",
    "text": "[INSERT WORKSHOP DATE/TIME]\n[INSERT WORKSHOP LOCATION]"
  },
  {
    "objectID": "index.html#arrival",
    "href": "index.html#arrival",
    "title": "[INSERT WORKSHOP SHORT TITLE]",
    "section": "Arrival",
    "text": "Arrival\nThe event starts at XXX on the XXX and will take place at XXX."
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "[INSERT WORKSHOP SHORT TITLE]",
    "section": "Schedule",
    "text": "Schedule\n\n\n\nTime\nEvent\n\n\n\n\nPLACEHOLDER\nPLACEHOLDER\n\n\nPLACEHOLDER\nPLACEHOLDER\n\n\nPLACEHOLDER\nPLACEHOLDER\n\n\nPLACEHOLDER\nPLACEHOLDER\n\n\nPLACEHOLDER\nPLACEHOLDER\n\n\nPLACEHOLDER\nPLACEHOLDER"
  },
  {
    "objectID": "index.html#instructors",
    "href": "index.html#instructors",
    "title": "[INSERT WORKSHOP SHORT TITLE]",
    "section": "Instructors",
    "text": "Instructors"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "[INSERT WORKSHOP SHORT TITLE]",
    "section": "Installation",
    "text": "Installation"
  },
  {
    "objectID": "03_UNIT_NAME/index.html",
    "href": "03_UNIT_NAME/index.html",
    "title": "[UNIT SHORT NAME]",
    "section": "",
    "text": "Add content",
    "crumbs": [
      "[UNIT SHORT NAME]"
    ]
  }
]